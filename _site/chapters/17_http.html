<!doctype html>
<head>
  <meta charset="utf-8">
  <title>HTTP :: Eloquent JavaScript</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script>
  <script>var chapNum = 17;var sandboxLoadFiles = ["code/chapter/17_http.js", "code/promise.js"];</script>
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-53624335-3', 'auto');
  ga('send', 'pageview');

  </script>
</head>

<article>
<nav>
  <a href="16_canvas.html" title="capítulo previo">◀</a>
  <a href="index.html" title="cover">◆</a>
  <a href="18_forms.html" title="capítulo siguiente">▶</a>
</nav>

<h1><div class=chap_num>Capítulo 17</div>HTTP</h1>
<blockquote>
<p><a class=p_ident id="p_QvqpbswJB1" href="#p_QvqpbswJB1"></a>The dream behind the Web is of a common information space in which we
communicate by sharing information. Its universality is essential: the
fact that a hypertext link can point to anything, be it personal,
local or global, be it draft or highly polished.</p>
 <footer>Tim Berners-Lee, <cite>The World Wide Web: A very short personal history</cite></footer>
</blockquote>
<p><a class=p_ident id="p_C6+RXvCvFu" href="#p_C6+RXvCvFu"></a>The
<em>Hypertext Transfer Protocol</em>, already mentioned in
<a href="12_browser.html#web">Chapter 12</a>, is the mechanism through which
data is requested and provided on the World Wide Web. This chapter
describes the protocol in more detail and explains the way browser
JavaScript has access to it.</p>
<h2><a class=h_ident id="h_vXdZCu/Tty" href="#h_vXdZCu/Tty"></a>The protocol</h2>
<p><a class=p_ident id="p_uAGANEYkBZ" href="#p_uAGANEYkBZ"></a>If you type <em>eloquentjavascript.net/17_http.html</em> into
your browser&#8217;s address bar, the browser first looks up the
address of the server associated with <em>eloquentjavascript.net</em>
and tries to open a TCP connection to it on port 80, the
default port for HTTP traffic. If the server exists and
accepts the connection, the browser sends something like this:</p>
<pre data-language="http" class="snippet cm-s-default"><a class=c_ident id="c_B1oAtzWnlx" href="#c_B1oAtzWnlx"></a><span class="cm-keyword">GET</span> <span class="cm-string-2">/17_http.html</span> <span class="cm-keyword">HTTP/1.1</span>
<span class="cm-atom">Host:</span><span class="cm-string"> eloquentjavascript.net</span>
<span class="cm-atom">User-Agent:</span><span class="cm-string"> Your browser's name</span></pre>
<p><a class=p_ident id="p_cpaXDnG/vq" href="#p_cpaXDnG/vq"></a>Then the server responds, through that same connection.</p>
<pre data-language="http" class="snippet cm-s-default"><a class=c_ident id="c_jb8msMtad8" href="#c_jb8msMtad8"></a><span class="cm-keyword">HTTP/1.1</span> <span class="cm-positive cm-success">200</span> OK
<span class="cm-atom">Content-Length:</span><span class="cm-string"> 65585</span>
<span class="cm-atom">Content-Type:</span><span class="cm-string"> text/html</span>
<span class="cm-atom">Last-Modified:</span><span class="cm-string"> Wed, 09 Apr 2014 10:48:09 GMT</span>

&lt;!doctype html>
... the rest of the document</pre>
<p><a class=p_ident id="p_RRCiB3G5cb" href="#p_RRCiB3G5cb"></a>The browser then takes the part of the response after the blank
line and displays it as an HTML document.</p>
<p><a class=p_ident id="p_EF5P7+qf9n" href="#p_EF5P7+qf9n"></a>The information sent by the client is called the
<em>request</em>. It starts with this line:</p>
<pre data-language="http" class="snippet cm-s-default"><a class=c_ident id="c_/t2TOTMJ5I" href="#c_/t2TOTMJ5I"></a><span class="cm-keyword">GET</span> <span class="cm-string-2">/17_http.html</span> <span class="cm-keyword">HTTP/1.1</span></pre>
<p><a class=p_ident id="p_0OgmCKjRs2" href="#p_0OgmCKjRs2"></a>The first word is
the <em>method</em> of the request. <code>GET</code> means that we want to <em>get</em>
the specified resource. Other common methods are <code>DELETE</code> to delete a
resource, <code>PUT</code> to replace it, and <code>POST</code> to send information to it.
Note that the server is not obliged to carry out every request it
gets. If you walk up to a random website and tell it to <code>DELETE</code> its
main page, it&#8217;ll probably refuse.</p>
<p><a class=p_ident id="p_dRtHLefq7L" href="#p_dRtHLefq7L"></a>The part after the method name is the path of the
resource the request applies to. In the simplest case, a resource
is simply a file on the server, but the protocol doesn&#8217;t
require it to be. A resource may be anything that can be transferred <em>as if</em>
it is a file. Many servers generate the responses they produce on the
fly. For example, if you open
<a href="http://twitter.com/marijnjh"><em>twitter.com/marijnjh</em></a>, the server looks
in its database for a user named <em>marijnjh</em>, and if it finds one, it
will generate a profile page for that user.</p>
<p><a class=p_ident id="p_M95qaU9kuN" href="#p_M95qaU9kuN"></a>After the resource path, the first line of the request mentions
<code>HTTP/1.1</code> to indicate the version of the HTTP protocol
it is using.</p>
<p><a class=p_ident id="p_pIMelD1mZh" href="#p_pIMelD1mZh"></a>The server&#8217;s response will start with a version
as well, followed by the status of the response, first as a
three-digit status code and then as a human-readable string.</p>
<pre data-language="http" class="snippet cm-s-default"><a class=c_ident id="c_0nHloyp4nW" href="#c_0nHloyp4nW"></a><span class="cm-keyword">HTTP/1.1</span> <span class="cm-positive cm-success">200</span> OK</pre>
<p><a class=p_ident id="p_I8BGMaErRo" href="#p_I8BGMaErRo"></a>Status codes starting with a 2 indicate that the request succeeded.
Codes starting with 4 mean there was something wrong with the
request. 404 is probably the most famous HTTP status code—it means
that the resource that was requested could not be found. Codes that
start with 5 mean an error happened on the server and the request
is not to blame.</p>
<p id="headers"><a class=p_ident id="p_CA64oLhdLd" href="#p_CA64oLhdLd"></a>The first line of a request or response may be followed by
any number of <em>headers</em>. These are lines in the form “name: value”
that specify extra information about the request or response. These
headers were part of the example response:</p>
<pre>Content-Length: 65585
Content-Type: text/html
Last-Modified: Wed, 09 Apr 2014 10:48:09 GMT</pre>
<p><a class=p_ident id="p_04zcUGZ8sT" href="#p_04zcUGZ8sT"></a>This tells us the size and type of the response document. In
this case, it is an HTML document of 65,585 bytes. It also tells us when
that document was last modified.</p>
<p><a class=p_ident id="p_dIM0DmAcMY" href="#p_dIM0DmAcMY"></a>For the most part, a client or server
decides which headers to include in a request or response,
though a few headers are required. For example, the <code>Host</code> header,
which specifies the hostname, should be included in a request
because a server might be serving multiple hostnames on a single
IP address, and without that header, the server won&#8217;t know which host the
client is trying to talk to.</p>
<p><a class=p_ident id="p_DeF17lBSIn" href="#p_DeF17lBSIn"></a>After the headers, both requests and
responses may include a blank line followed by a <em>body</em>, which
contains the data being sent. <code>GET</code> and <code>DELETE</code> requests don&#8217;t send
along any data, but <code>PUT</code> and <code>POST</code> requests do.
Similarly, some response types, such as error responses, do not
require a body.</p>
<h2><a class=h_ident id="h_G1xxLfiYeu" href="#h_G1xxLfiYeu"></a>Browsers and HTTP</h2>
<p><a class=p_ident id="p_FaMpawa4Gl" href="#p_FaMpawa4Gl"></a>As we saw in the example, a browser will make a request
when we enter a URL in its address bar. When the resulting
HTML page references other files, such as images and JavaScript
files, those are also fetched.</p>
<p><a class=p_ident id="p_7zqOoBgyIg" href="#p_7zqOoBgyIg"></a>A moderately complicated website can easily
include anywhere from 10 to 200 resources. To be able to
fetch those quickly, browsers will make several requests
simultaneously, rather than waiting for the responses one at a time.
Such documents are always fetched using <code>GET</code>
requests.</p>
<p id="http_forms"><a class=p_ident id="p_Aub9jfdnAA" href="#p_Aub9jfdnAA"></a>HTML pages may include <em>forms</em>, which allow
the user to fill out information and send it to the server. This is an
example of a form:</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_GZhGQeEihW" href="#c_GZhGQeEihW"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">form</span> <span class="cm-attribute">method</span>=<span class="cm-string">"GET"</span> <span class="cm-attribute">action</span>=<span class="cm-string">"example/message.html"</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>Name: <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">input</span> <span class="cm-attribute">type</span>=<span class="cm-string">"text"</span> <span class="cm-attribute">name</span>=<span class="cm-string">"name"</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>Message:<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">br</span><span class="cm-tag cm-bracket">>&lt;</span><span class="cm-tag">textarea</span> <span class="cm-attribute">name</span>=<span class="cm-string">"message"</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">textarea</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">>&lt;</span><span class="cm-tag">button</span> <span class="cm-attribute">type</span>=<span class="cm-string">"submit"</span><span class="cm-tag cm-bracket">></span>Send<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">>&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">></span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">form</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_7XkP0qerQY" href="#p_7XkP0qerQY"></a>This code describes a form with two
fields: a small one asking for a name and a larger one to write a
message in. When you click the Send button, the information in
those fields will be encoded into a <em>query string</em>. When the
<code>&lt;form&gt;</code> element&#8217;s <code>method</code> attribute is <code>GET</code> (or is omitted), that
query string is tacked onto the <code>action</code> URL, and the browser makes a
<code>GET</code> request to that URL.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_3P+4LKZOZu" href="#c_3P+4LKZOZu"></a>GET /example/message.html?name=Jean<span class="cm-error">&amp;message</span>=Yes%3F HTTP/1.1</pre>
<p><a class=p_ident id="p_ExLzsDAoPr" href="#p_ExLzsDAoPr"></a>The start of a query string is indicated
by a question mark. After that follow pairs of names and values,
corresponding to the <code>name</code> attribute on the form field elements and
the content of those elements, respectively. An ampersand character (<code>&amp;</code>) is used to separate
the pairs.</p>
<p><a class=p_ident id="p_4Eo/x5v9Qy" href="#p_4Eo/x5v9Qy"></a>The actual message encoded
in the previous URL is “Yes?”, even though the question mark is replaced
by a strange code. Some characters in query strings must be
escaped. The question mark, represented as <code>%3F</code>, is one of those.
There seems to be an unwritten rule that every format needs its
own way of escaping characters. This one, called <em>URL
encoding</em>, uses a percent sign followed by two hexadecimal digits
that encode the character code. In this case, 3F, which is 63 in
decimal notation, is the code of a question mark character. JavaScript
provides the <code>encodeURIComponent</code> and <code>decodeURIComponent</code> functions
to encode and decode this format.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_iUqK1/d6dT" href="#c_iUqK1/d6dT"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">encodeURIComponent</span>(<span class="cm-string">"Hello &amp; goodbye"</span>));
<span class="cm-comment">// → Hello%20%26%20goodbye</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">decodeURIComponent</span>(<span class="cm-string">"Hello%20%26%20goodbye"</span>));
<span class="cm-comment">// → Hello &amp; goodbye</span></pre>
<p><a class=p_ident id="p_l15d9HkVlZ" href="#p_l15d9HkVlZ"></a>If we change the <code>method</code> attribute
of the HTML form in the example we saw earlier to <code>POST</code>, the HTTP request made to submit the
form will use the <code>POST</code> method and put the query string in
body of the request, rather than adding it to the URL.</p>
<pre data-language="http" class="snippet cm-s-default"><a class=c_ident id="c_41i/U10MNd" href="#c_41i/U10MNd"></a><span class="cm-keyword">POST</span> <span class="cm-string-2">/example/message.html</span> <span class="cm-keyword">HTTP/1.1</span>
<span class="cm-atom">Content-length:</span><span class="cm-string"> 24</span>
<span class="cm-atom">Content-type:</span><span class="cm-string"> application/x-www-form-urlencoded</span>

name=Jean&amp;message=Yes%3F</pre>
<p><a class=p_ident id="p_K5PHhwPNop" href="#p_K5PHhwPNop"></a>By convention, the <code>GET</code> method is used for requests that do not have
side effects, such as doing a search. Requests that change something on
the server, such as creating a new account or posting a message, should
be expressed with other methods, such as <code>POST</code>. Client-side software,
such as a browser, knows that it shouldn&#8217;t blindly make <code>POST</code>
requests but will often implicitly make <code>GET</code> requests—for example, to
prefetch a resource it believes the user will soon need.</p>
<p><a class=p_ident id="p_mOjZBRUuCo" href="#p_mOjZBRUuCo"></a>The <a href="18_forms.html#forms">next chapter</a> will return to forms
and talk about how we can script them with JavaScript.</p>
<h2 id="xmlhttprequest"><a class=h_ident id="h_Gh3HVKEFJQ" href="#h_Gh3HVKEFJQ"></a>XMLHttpRequest</h2>
<p><a class=p_ident id="p_sEiPS/dTmx" href="#p_sEiPS/dTmx"></a>The interface through
which browser JavaScript can make HTTP requests is called
<code>XMLHttpRequest</code> (note the inconsistent capitalization). It was
designed by Microsoft, for its Internet Explorer
browser, in the late 1990s. During this time, the XML file format
was <em>very</em> popular in the world of business software—a world where
Microsoft has always been at home. In fact, it was so popular that the
acronym XML was tacked onto the front of the name of an interface for
HTTP, which is in no way tied to XML.</p>
<p><a class=p_ident id="p_ED7N2rpOmD" href="#p_ED7N2rpOmD"></a>The name isn&#8217;t completely
nonsensical, though. The interface allows you to parse response documents as
XML if you want. Conflating two distinct concepts (making a request
and parsing the response) into a single thing is terrible design,
of course, but so it goes.</p>
<p><a class=p_ident id="p_huklKLNeHt" href="#p_huklKLNeHt"></a>When the <code>XMLHttpRequest</code> interface was added to Internet Explorer, it
allowed people to do things with JavaScript that had been very hard
before. For example, websites started showing lists of suggestions
when the user was typing something into a text field. The script would
send the text to the server over HTTP as the user typed. The server,
which had some database of possible inputs, would
match the database entries against the partial input and send back possible
completions to show the user. This was
considered spectacular—people were used to waiting for a full page reload
for every interaction with a website.</p>
<p><a class=p_ident id="p_yNW5lu4ilN" href="#p_yNW5lu4ilN"></a>The other
significant browser at that time, Mozilla (later Firefox), did not
want to be left behind. To allow people to do similarly neat things in
<em>its</em> browser, Mozilla copied the interface, including the bogus name.
The next generation of browsers followed this example, and today
<code>XMLHttpRequest</code> is a de facto standard interface.</p>
<h2><a class=h_ident id="h_NfPWoSbXzR" href="#h_NfPWoSbXzR"></a>Sending a request</h2>
<p><a class=p_ident id="p_EQKwKXO14E" href="#p_EQKwKXO14E"></a>To make a simple
request, we create a request object with the <code>XMLHttpRequest</code>
constructor and call its <code>open</code> and <code>send</code> methods.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_S4pyLFcZea" href="#c_S4pyLFcZea"></a><span class="cm-keyword">var</span> <span class="cm-variable">req</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">XMLHttpRequest</span>();
<span class="cm-variable">req</span>.<span class="cm-property">open</span>(<span class="cm-string">"GET"</span>, <span class="cm-string">"example/data.txt"</span>, <span class="cm-atom">false</span>);
<span class="cm-variable">req</span>.<span class="cm-property">send</span>(<span class="cm-atom">null</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">req</span>.<span class="cm-property">responseText</span>);
<span class="cm-comment">// → This is the content of data.txt</span></pre>
<p><a class=p_ident id="p_wgyJl8Iwi6" href="#p_wgyJl8Iwi6"></a>The <code>open</code>
method configures the request. In this case, we choose to make a <code>GET</code>
request for the <em>example/data.txt</em> file. URLs that don&#8217;t start
with a protocol name (such as <em>http:</em>) are relative, which means that
they are interpreted relative to the current document. When they start
with a slash (/), they replace the current path, which is the part after the
server name. When they do not, the part of the current path up to
and including its last slash character is put in front of the relative
URL.</p>
<p><a class=p_ident id="p_AodYq0EUqt" href="#p_AodYq0EUqt"></a>After opening the request, we can send it with the <code>send</code>
method. The argument to send is the request body. For <code>GET</code> requests,
we can pass null. If the third argument to <code>open</code> was <code>false</code>, <code>send</code>
will return only  after the response to our request was received. We
can read the request object&#8217;s <code>responseText</code> property to get the
response body.</p>
<p><a class=p_ident id="p_OWl9lqs7j6" href="#p_OWl9lqs7j6"></a>The other
information included in the response can also be extracted from this
object. The status code is accessible through the <code>status</code>
property, and the human-readable status text is accessible through <code>statusText</code>.
Headers can be read with <code>getResponseHeader</code>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_7D9Ia+cyzu" href="#c_7D9Ia+cyzu"></a><span class="cm-keyword">var</span> <span class="cm-variable">req</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">XMLHttpRequest</span>();
<span class="cm-variable">req</span>.<span class="cm-property">open</span>(<span class="cm-string">"GET"</span>, <span class="cm-string">"example/data.txt"</span>, <span class="cm-atom">false</span>);
<span class="cm-variable">req</span>.<span class="cm-property">send</span>(<span class="cm-atom">null</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">req</span>.<span class="cm-property">status</span>, <span class="cm-variable">req</span>.<span class="cm-property">statusText</span>);
<span class="cm-comment">// → 200 OK</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">req</span>.<span class="cm-property">getResponseHeader</span>(<span class="cm-string">"content-type"</span>));
<span class="cm-comment">// → text/plain</span></pre>
<p><a class=p_ident id="p_lJQuRg3OV0" href="#p_lJQuRg3OV0"></a>Header names are
case-insensitive. They are usually written with a capital letter at
the start of each word, such as “Content-Type”, but “content-type” and
“cOnTeNt-TyPe” refer to the same header.</p>
<p><a class=p_ident id="p_UkSLHXvU3D" href="#p_UkSLHXvU3D"></a>The browser will
automatically add some request headers, such as “Host” and those
needed for the server to figure out the size of the body. But you can
add your own headers with the <code>setRequestHeader</code> method. This is
needed only for advanced uses and requires the cooperation of the
server you are talking to—a server is free to ignore headers it
does not know how to handle.</p>
<h2><a class=h_ident id="h_B6OtWq8Z7x" href="#h_B6OtWq8Z7x"></a>Asynchronous Requests</h2>
<p><a class=p_ident id="p_xK9lUJ4zpm" href="#p_xK9lUJ4zpm"></a>In the examples we
saw, the request has finished when the call to <code>send</code> returns. This is
convenient because it means properties such as <code>responseText</code> are
available immediately. But it also mean that our program is suspended
as long as the browser and server are communicating. When the
connection is bad, the server is slow, or the file is big, that
might take quite a while. Worse, because no event handlers can fire
while our program is suspended, the whole document will become
unresponsive.</p>
<p><a class=p_ident id="p_zjXoJQW9df" href="#p_zjXoJQW9df"></a>If we pass
<code>true</code> as the third argument to <code>open</code>, the request is <em>asynchronous</em>.
This means that when we call <code>send</code>, the only thing that happens right
away is that the request is scheduled to be sent. Our program can
continue, and the browser will take care of the sending and receiving
of data in the background.</p>
<p><a class=p_ident id="p_4WsIyXtb4Y" href="#p_4WsIyXtb4Y"></a>But as long as the request is running, we won&#8217;t be able to access the
response. We need a mechanism that will notify us when the data is
available.</p>
<p><a class=p_ident id="p_icR3wVhR/6" href="#p_icR3wVhR/6"></a>For this, we must listen for the
<code>"load"</code> event on the request object.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_Hhajlonku9" href="#c_Hhajlonku9"></a><span class="cm-keyword">var</span> <span class="cm-variable">req</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">XMLHttpRequest</span>();
<span class="cm-variable">req</span>.<span class="cm-property">open</span>(<span class="cm-string">"GET"</span>, <span class="cm-string">"example/data.txt"</span>, <span class="cm-atom">true</span>);
<span class="cm-variable">req</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Done:"</span>, <span class="cm-variable">req</span>.<span class="cm-property">status</span>);
});
<span class="cm-variable">req</span>.<span class="cm-property">send</span>(<span class="cm-atom">null</span>);</pre>
<p><a class=p_ident id="p_CAzrPM0mYP" href="#p_CAzrPM0mYP"></a>Just like the use
of <code>requestAnimationFrame</code> in <a href="15_game.html#game">Chapter 15</a>, this
forces us to use an asynchronous style of programming, wrapping the
things that have to be done after the request in a function and
arranging for that to be called at the appropriate time. We will come
back to this <a href="17_http.html#promises">later</a>.</p>
<h2><a class=h_ident id="h_FhSkVawGDi" href="#h_FhSkVawGDi"></a>Fetching XML Data</h2>
<p><a class=p_ident id="p_96cGuKLvjr" href="#p_96cGuKLvjr"></a>When the
resource retrieved by an <code>XMLHttpRequest</code> object is an XML
document, the object&#8217;s <code>responseXML</code> property will hold a parsed
representation of this document. This representation works much like
the DOM discussed in <a href="13_dom.html#dom">Chapter 13</a>, except that
it doesn&#8217;t have HTML-specific functionality like the <code>style</code> property.
The object that <code>responseXML</code> holds corresponds to the <code>document</code>
object. Its <code>documentElement</code> property refers to the outer tag of the
XML document. In the following document (<em>example/fruit.xml</em>), that would
would be the <code>&lt;fruits&gt;</code> tag:</p>
<pre data-language="application/xml" class="snippet cm-s-default"><a class=c_ident id="c_RtdE6qlfWc" href="#c_RtdE6qlfWc"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">fruits</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">fruit</span> <span class="cm-attribute">name</span>=<span class="cm-string">"banana"</span> <span class="cm-attribute">color</span>=<span class="cm-string">"yellow"</span><span class="cm-tag cm-bracket">/></span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">fruit</span> <span class="cm-attribute">name</span>=<span class="cm-string">"lemon"</span> <span class="cm-attribute">color</span>=<span class="cm-string">"yellow"</span><span class="cm-tag cm-bracket">/></span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">fruit</span> <span class="cm-attribute">name</span>=<span class="cm-string">"cherry"</span> <span class="cm-attribute">color</span>=<span class="cm-string">"red"</span><span class="cm-tag cm-bracket">/></span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">fruits</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_3NjSjUCAEg" href="#p_3NjSjUCAEg"></a>We can retrieve such a file like this:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_vkLnjsVdpV" href="#c_vkLnjsVdpV"></a><span class="cm-keyword">var</span> <span class="cm-variable">req</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">XMLHttpRequest</span>();
<span class="cm-variable">req</span>.<span class="cm-property">open</span>(<span class="cm-string">"GET"</span>, <span class="cm-string">"example/fruit.xml"</span>, <span class="cm-atom">false</span>);
<span class="cm-variable">req</span>.<span class="cm-property">send</span>(<span class="cm-atom">null</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">req</span>.<span class="cm-property">responseXML</span>.<span class="cm-property">querySelectorAll</span>(<span class="cm-string">"fruit"</span>).<span class="cm-property">length</span>);
<span class="cm-comment">// → 3</span></pre>
<p><a class=p_ident id="p_5fmUcEnbjN" href="#p_5fmUcEnbjN"></a>XML documents can be used to exchange structured
information with the server. Their form—tags nested inside other
tags—lends itself well to storing most types of data, or at least
better than flat text files. The DOM interface is rather clumsy for
extracting information, though, and XML documents tend to be
verbose. It is often a better idea to communicate using JSON data,
which is easier to read and write, both for programs and for humans.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_b665cw/Yoz" href="#c_b665cw/Yoz"></a><span class="cm-keyword">var</span> <span class="cm-variable">req</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">XMLHttpRequest</span>();
<span class="cm-variable">req</span>.<span class="cm-property">open</span>(<span class="cm-string">"GET"</span>, <span class="cm-string">"example/fruit.json"</span>, <span class="cm-atom">false</span>);
<span class="cm-variable">req</span>.<span class="cm-property">send</span>(<span class="cm-atom">null</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">JSON</span>.<span class="cm-property">parse</span>(<span class="cm-variable">req</span>.<span class="cm-property">responseText</span>));
<span class="cm-comment">// → {banana: "yellow", lemon: "yellow", cherry: "red"}</span></pre>
<h2 id="http_sandbox"><a class=h_ident id="h_4h3DL+zoLY" href="#h_4h3DL+zoLY"></a>HTTP sandboxing</h2>
<p><a class=p_ident id="p_RMl+jfbkqI" href="#p_RMl+jfbkqI"></a>Making HTTP requests in web page scripts once
again raises concerns about security. The person who controls the
script might not have the same interests as the person on whose
computer it is running. More specifically, if I visit <em>themafia.org</em>,
I do not want its scripts to be able to make a request to
<em>mybank.com</em>, using identifying information from my browser, with
instructions to transfer all my money to some random mafia
account.</p>
<p><a class=p_ident id="p_qIXFpjWK5N" href="#p_qIXFpjWK5N"></a>It is possible for websites to protect themselves against such
attacks, but that requires effort, and many websites fail to do it.
For this reason, browsers protect us by disallowing scripts to make
HTTP requests to other <em>domains</em> (names such as <em>themafia.org</em> and
<em>mybank.com</em>).</p>
<p><a class=p_ident id="p_UCqQ0Yw7G5" href="#p_UCqQ0Yw7G5"></a>This
can be an annoying problem when building systems that want to access
several domains for legitimate reasons. Fortunately, servers can
include a header like this in their response to explicitly
indicate to browsers that it is okay for the request to come from
other domains:</p>
<pre>Access-Control-Allow-Origin: *</pre>
<h2><a class=h_ident id="h_RR7vot6vKN" href="#h_RR7vot6vKN"></a>Abstracting requests</h2>
<p><a class=p_ident id="p_3R01AAt3PW" href="#p_3R01AAt3PW"></a>In
<a href="10_modules.html#amd">Chapter 10</a>, in our implementation of the AMD
module system, we used a hypothetical function called
<code>backgroundReadFile</code>. It took a filename and a function and called
that function with the contents of the file when it had finished
fetching it. Here&#8217;s a simple implementation of that function:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_db2tCQrwnC" href="#c_db2tCQrwnC"></a><span class="cm-keyword">function</span> <span class="cm-variable">backgroundReadFile</span>(<span class="cm-def">url</span>, <span class="cm-def">callback</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">req</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">XMLHttpRequest</span>();
  <span class="cm-variable-2">req</span>.<span class="cm-property">open</span>(<span class="cm-string">"GET"</span>, <span class="cm-variable-2">url</span>, <span class="cm-atom">true</span>);
  <span class="cm-variable-2">req</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">req</span>.<span class="cm-property">status</span> <span class="cm-operator">&lt;</span> <span class="cm-number">400</span>)
      <span class="cm-variable-2">callback</span>(<span class="cm-variable-2">req</span>.<span class="cm-property">responseText</span>);
  });
  <span class="cm-variable-2">req</span>.<span class="cm-property">send</span>(<span class="cm-atom">null</span>);
}</pre>
<p><a class=p_ident id="p_nNxmesIyV4" href="#p_nNxmesIyV4"></a>This simple abstraction makes it easier to use
<code>XMLHttpRequest</code> for simple <code>GET</code> requests. If you are writing a
program that has to make HTTP requests, it is a good idea to use a
helper function so that you don&#8217;t end up repeating the ugly
<code>XMLHttpRequest</code> pattern all through your code.</p>
<p><a class=p_ident id="p_8Shcg3/WzI" href="#p_8Shcg3/WzI"></a>The function argument&#8217;s
name, <code>callback</code>, is a term that is often used to describe functions
like this. A callback function is given to other code to provide that
code with a way to “call us back” later.</p>
<p><a class=p_ident id="p_xKwFWu3zF0" href="#p_xKwFWu3zF0"></a>It is not hard to write an HTTP utility function, tailored to what your
application is doing. The previous one does only <code>GET</code> requests and
doesn&#8217;t give us control over the headers or the request body. You
could write another variant for <code>POST</code> requests or a more generic one
that supports various kinds of requests. Many JavaScript libraries
also provide wrappers for <code>XMLHttpRequest</code>.</p>
<p><a class=p_ident id="p_2cF6BoTzh8" href="#p_2cF6BoTzh8"></a>The main problem with the previous
wrapper is its handling of failure. When the request returns
a status code that indicates an error (400 and up), it does
nothing. This might be okay, in some circumstances, but imagine we put
a “loading” indicator on the page to indicate that we are fetching
information. If the request fails because the server crashed or the
connection is briefly interrupted, the page will just sit there,
misleadingly looking like it is doing something. The user will wait
for a while, get impatient, and consider the site uselessly flaky.</p>
<p><a class=p_ident id="p_GM6g10t1uS" href="#p_GM6g10t1uS"></a>We should also have an option to be notified when the request fails
so that we can take appropriate action. For example, we could remove the
“loading” message and inform the user that something went wrong.</p>
<p><a class=p_ident id="p_qQG5mkGJ5M" href="#p_qQG5mkGJ5M"></a>Error handling in asynchronous code is even
trickier than error handling in synchronous code. Because we often need
to defer part of our work, putting it in a callback function, the
scope of a <code>try</code> block becomes meaningless. In the following code, the
exception will <em>not</em> be caught because the call to
<code>backgroundReadFile</code> returns immediately. Control then leaves the
<code>try</code> block, and the function it was given won&#8217;t be called until
later.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_BOjAGQyuin" href="#c_BOjAGQyuin"></a><span class="cm-keyword">try</span> {
  <span class="cm-variable">backgroundReadFile</span>(<span class="cm-string">"example/data.txt"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">text</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">text</span> <span class="cm-operator">!=</span> <span class="cm-string">"expected"</span>)
      <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">"That was unexpected"</span>);
  });
} <span class="cm-keyword">catch</span> (<span class="cm-def">e</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Hello from the catch block"</span>);
}</pre>
<p id="getURL"><a class=p_ident id="p_ZP2klx8rqb" href="#p_ZP2klx8rqb"></a>To handle failing
requests, we have to allow an additional function to be passed to our
wrapper and call that when a request goes wrong. Alternatively, we
can use the convention that if the request fails, an additional
argument describing the problem is passed to the regular callback
function. Here&#8217;s an example:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_eZVbiljj+e" href="#c_eZVbiljj+e"></a><span class="cm-keyword">function</span> <span class="cm-variable">getURL</span>(<span class="cm-def">url</span>, <span class="cm-def">callback</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">req</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">XMLHttpRequest</span>();
  <span class="cm-variable-2">req</span>.<span class="cm-property">open</span>(<span class="cm-string">"GET"</span>, <span class="cm-variable-2">url</span>, <span class="cm-atom">true</span>);
  <span class="cm-variable-2">req</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">req</span>.<span class="cm-property">status</span> <span class="cm-operator">&lt;</span> <span class="cm-number">400</span>)
      <span class="cm-variable-2">callback</span>(<span class="cm-variable-2">req</span>.<span class="cm-property">responseText</span>);
    <span class="cm-keyword">else</span>
      <span class="cm-variable-2">callback</span>(<span class="cm-atom">null</span>, <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">"Request failed: "</span> <span class="cm-operator">+</span>
                               <span class="cm-variable-2">req</span>.<span class="cm-property">statusText</span>));
  });
  <span class="cm-variable-2">req</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"error"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable-2">callback</span>(<span class="cm-atom">null</span>, <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">"Network error"</span>));
  });
  <span class="cm-variable-2">req</span>.<span class="cm-property">send</span>(<span class="cm-atom">null</span>);
}</pre>
<p><a class=p_ident id="p_OwEcgNZRXQ" href="#p_OwEcgNZRXQ"></a>We have added a handler for the <code>"error"</code> event,
which will be signaled when the request fails entirely. We also call
the callback function with an error argument when the request
completes with a status code that indicates an error.</p>
<p><a class=p_ident id="p_nye9N1QULd" href="#p_nye9N1QULd"></a>Code using <code>getURL</code> must then check whether an error was given and, if
it finds one, handle it.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_V6+MDOjkL1" href="#c_V6+MDOjkL1"></a><span class="cm-variable">getURL</span>(<span class="cm-string">"data/nonsense.txt"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">content</span>, <span class="cm-def">error</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">error</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>)
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Failed to fetch nonsense.txt: "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">error</span>);
  <span class="cm-keyword">else</span>
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"nonsense.txt: "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">content</span>);
});</pre>
<p><a class=p_ident id="p_j4unfsTO1z" href="#p_j4unfsTO1z"></a>This
does not help when it comes to exceptions. When chaining several
asynchronous actions together, an exception at any point of the chain
will still (unless you wrap each handling function in its own
<code>try/catch</code> block) land at the top level and abort your chain of
actions.</p>
<h2 id="promises"><a class=h_ident id="h_sdRy5CTAP/" href="#h_sdRy5CTAP/"></a>Promises</h2>
<p><a class=p_ident id="p_v7YfQvxwuV" href="#p_v7YfQvxwuV"></a>For complicated
projects, writing asynchronous code in plain callback style is hard to
do correctly. It is easy to forget to check for an error or to allow
an unexpected exception to cut the program short in a crude way.
Additionally, arranging for correct error handling when the error has
to flow through multiple callback functions and <code>catch</code> blocks is
tedious.</p>
<p><a class=p_ident id="p_mO96gXoG0q" href="#p_mO96gXoG0q"></a>There have been a lot of attempts to
solve this with extra abstractions. One of the more successful ones is
called <em>promises</em>. Promises wrap an asynchronous action in an object,
which can be passed around and told to do certain things when the
action finishes or fails. This interface is set to become part of the next
version of the JavaScript language but can already be used as a
library.</p>
<p><a class=p_ident id="p_HgVayjbMGB" href="#p_HgVayjbMGB"></a>The interface for promises isn&#8217;t entirely intuitive, but it is
powerful. This chapter will only roughly describe it. You can find a more thorough
treatment at
<a href="https://www.promisejs.org/"><em>www.promisejs.org</em></a>.</p>
<p><a class=p_ident id="p_JxpiCLDcQ3" href="#p_JxpiCLDcQ3"></a>To create a promise object, we call the
<code>Promise</code> constructor, giving it a function that initializes the
asynchronous action. The constructor calls that function, passing it
two arguments, which are themselves functions. The first should be
called when the action finishes successfully, and the second should be called when it
fails.</p>
<p><a class=p_ident id="p_WoWIWkMqow" href="#p_WoWIWkMqow"></a>Once again, here is our wrapper for <code>GET</code>
requests, this time returning a promise. We&#8217;ll simply call it <code>get</code>
this time.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_oGXXgqh698" href="#c_oGXXgqh698"></a><span class="cm-keyword">function</span> <span class="cm-variable">get</span>(<span class="cm-def">url</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>(<span class="cm-keyword">function</span>(<span class="cm-def">succeed</span>, <span class="cm-def">fail</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">req</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">XMLHttpRequest</span>();
    <span class="cm-variable-2">req</span>.<span class="cm-property">open</span>(<span class="cm-string">"GET"</span>, <span class="cm-variable-2">url</span>, <span class="cm-atom">true</span>);
    <span class="cm-variable-2">req</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">req</span>.<span class="cm-property">status</span> <span class="cm-operator">&lt;</span> <span class="cm-number">400</span>)
        <span class="cm-variable-2">succeed</span>(<span class="cm-variable-2">req</span>.<span class="cm-property">responseText</span>);
      <span class="cm-keyword">else</span>
        <span class="cm-variable-2">fail</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">"Request failed: "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">req</span>.<span class="cm-property">statusText</span>));
    });
    <span class="cm-variable-2">req</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"error"</span>, <span class="cm-keyword">function</span>() {
      <span class="cm-variable-2">fail</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">"Network error"</span>));
    });
    <span class="cm-variable-2">req</span>.<span class="cm-property">send</span>(<span class="cm-atom">null</span>);
  });
}</pre>
<p><a class=p_ident id="p_RE/bEoSIjp" href="#p_RE/bEoSIjp"></a>Note that the interface to the function itself is now a lot
simpler. You give it a URL, and it returns a promise. That promise
acts as a <em>handle</em> to the request&#8217;s outcome. It has a <code>then</code> method
that you can call with two functions: one to handle success and one
to handle failure.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_6FFNJj/UTy" href="#c_6FFNJj/UTy"></a><span class="cm-variable">get</span>(<span class="cm-string">"example/data.txt"</span>).<span class="cm-property">then</span>(<span class="cm-keyword">function</span>(<span class="cm-def">text</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"data.txt: "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">text</span>);
}, <span class="cm-keyword">function</span>(<span class="cm-def">error</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Failed to fetch data.txt: "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">error</span>);
});</pre>
<p><a class=p_ident id="p_4O6znqfcpb" href="#p_4O6znqfcpb"></a>So far, this is just another way to express the same
thing we already expressed. It is only when you need to chain
actions together that promises make a significant difference.</p>
<p><a class=p_ident id="p_uiJcYJELKb" href="#p_uiJcYJELKb"></a>Calling <code>then</code> produces a new promise, whose
result (the value passed to success handlers) depends on the return
value of the first function we passed to <code>then</code>. This function may
return another promise to indicate that more asynchronous work is
being done. In this case, the promise returned by <code>then</code> itself will
wait for the promise returned by the handler function, succeeding or
failing with the same value when it is resolved. When the handler
function returns a nonpromise value, the promise returned by <code>then</code>
immediately succeeds with that value as its result.</p>
<p><a class=p_ident id="p_wC6ZA4AmWr" href="#p_wC6ZA4AmWr"></a>This means you can use <code>then</code> to
transform the result of a promise. For example, this returns a promise
whose result is the content of the given URL, parsed as JSON:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_iYJTxgzQ/r" href="#c_iYJTxgzQ/r"></a><span class="cm-keyword">function</span> <span class="cm-variable">getJSON</span>(<span class="cm-def">url</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">get</span>(<span class="cm-variable-2">url</span>).<span class="cm-property">then</span>(<span class="cm-variable">JSON</span>.<span class="cm-property">parse</span>);
}</pre>
<p><a class=p_ident id="p_Cpzqy849cD" href="#p_Cpzqy849cD"></a>That last call to <code>then</code> did not specify a failure
handler. This is allowed. The error will be passed to the promise
returned by <code>then</code>, which is exactly what we want—<code>getJSON</code> does not
know what to do when something goes wrong, but hopefully its caller
does.</p>
<p><a class=p_ident id="p_xh6XPjbZAz" href="#p_xh6XPjbZAz"></a>As an example that shows the use of promises, we will build a
program that fetches a number of JSON files from the server and,
while it is doing that, shows the word <em>loading</em>. The JSON files
contain information about people, with links to files that represent
other people in properties such as <code>father</code>, <code>mother</code>, or <code>spouse</code>.</p>
<p><a class=p_ident id="p_JBcCWCd0HV" href="#p_JBcCWCd0HV"></a>We want to get the name of the mother of
the spouse of <em>example/bert.json</em>. And if something goes wrong, we
want to remove the <em>loading</em> text and show an error message instead.
Here is how that might be done with promises:</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class=c_ident id="c_+S6hPuikm/" href="#c_+S6hPuikm/"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span>
  <span class="cm-keyword">function</span> <span class="cm-variable">showMessage</span>(<span class="cm-def">msg</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">elt</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"div"</span>);
    <span class="cm-variable-2">elt</span>.<span class="cm-property">textContent</span> <span class="cm-operator">=</span> <span class="cm-variable-2">msg</span>;
    <span class="cm-keyword">return</span> <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable-2">elt</span>);
  }

  <span class="cm-keyword">var</span> <span class="cm-variable">loading</span> <span class="cm-operator">=</span> <span class="cm-variable">showMessage</span>(<span class="cm-string">"Loading..."</span>);
  <span class="cm-variable">getJSON</span>(<span class="cm-string">"example/bert.json"</span>).<span class="cm-property">then</span>(<span class="cm-keyword">function</span>(<span class="cm-def">bert</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable">getJSON</span>(<span class="cm-variable-2">bert</span>.<span class="cm-property">spouse</span>);
  }).<span class="cm-property">then</span>(<span class="cm-keyword">function</span>(<span class="cm-def">spouse</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable">getJSON</span>(<span class="cm-variable-2">spouse</span>.<span class="cm-property">mother</span>);
  }).<span class="cm-property">then</span>(<span class="cm-keyword">function</span>(<span class="cm-def">mother</span>) {
    <span class="cm-variable">showMessage</span>(<span class="cm-string">"The name is "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">mother</span>.<span class="cm-property">name</span>);
  }).<span class="cm-property">catch</span>(<span class="cm-keyword">function</span>(<span class="cm-def">error</span>) {
    <span class="cm-variable">showMessage</span>(<span class="cm-variable">String</span>(<span class="cm-variable-2">error</span>));
  }).<span class="cm-property">then</span>(<span class="cm-keyword">function</span>() {
    <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">removeChild</span>(<span class="cm-variable">loading</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">></span></pre>
<p><a class=p_ident id="p_jx/D3dcS2W" href="#p_jx/D3dcS2W"></a>The resulting program is
relatively compact and readable. The <code>catch</code> method is similar to
<code>then</code>, except that it only expects a failure handler and will pass
through the result unmodified in case of success. Much like with the
<code>catch</code> clause for the <code>try</code> statement, control will continue as
normal after the failure is caught. That way, the final <code>then</code>, which
removes the loading message, is always executed, even if something
went wrong.</p>
<p><a class=p_ident id="p_8DILWnDxzH" href="#p_8DILWnDxzH"></a>You can
think of the promise interface as implementing its own language for
asynchronous control flow. The extra method calls and function
expressions needed to achieve this make the code look somewhat
awkward but not remotely as awkward as it would look if we took care
of all the error handling ourselves.</p>
<h2><a class=h_ident id="h_OJmHENDG5y" href="#h_OJmHENDG5y"></a>Appreciating HTTP</h2>
<p><a class=p_ident id="p_dVrq2xCOfJ" href="#p_dVrq2xCOfJ"></a>When building a system that requires
communication between a JavaScript program running in the
browser (client-side) and a program on a server (server-side),
there are several different ways to model this communication.</p>
<p><a class=p_ident id="p_f4x0TdEU2h" href="#p_f4x0TdEU2h"></a>A commonly used model is that of
<em>remote procedure calls</em>. In this model, communication follows the
patterns of normal function calls, except that the function is
actually running on another machine. Calling it involves making a
request to the server that includes the function&#8217;s name and arguments.
The response to that request contains the returned value.</p>
<p><a class=p_ident id="p_7z+OqsDVUu" href="#p_7z+OqsDVUu"></a>When thinking in terms of remote procedure calls, HTTP is just a
vehicle for communication, and you will most likely write an
abstraction layer that hides it entirely.</p>
<p><a class=p_ident id="p_dOvEvBngFh" href="#p_dOvEvBngFh"></a>Another approach is to build your
communication around the concept of resources and HTTP
methods. Instead of a remote procedure called <code>addUser</code>, you use a
<code>PUT</code> request to <code>/users/larry</code>. Instead of encoding that user&#8217;s
properties in function arguments, you define a document format or use
an existing format that represents a user. The body of the <code>PUT</code> request
to create a new resource is then simply such a document. A resource is
fetched by making a <code>GET</code>
request to the resource&#8217;s URL (for example, <code>/user/larry</code>), which
returns the document representing the resource.</p>
<p><a class=p_ident id="p_6PHqO+Vd0H" href="#p_6PHqO+Vd0H"></a>This second approach makes it easier to use some of the features that
HTTP provides, such as support for caching resources (keeping a copy
on the client side). It can also help the coherence of your interface
since resources are easier to reason about than a jumble of functions.</p>
<h2><a class=h_ident id="h_oDqIFugKX4" href="#h_oDqIFugKX4"></a>Security and HTTPS</h2>
<p><a class=p_ident id="p_YUIH84Ok2d" href="#p_YUIH84Ok2d"></a>Data traveling over
the Internet tends to follow a long, dangerous road. To get
to its destination, it must hop through anything from coffee-shop Wi-Fi
networks to networks controlled by various companies and states.
At any point along its route it may be inspected or even modified.</p>
<p><a class=p_ident id="p_FkVKmUiG/R" href="#p_FkVKmUiG/R"></a>If it is important that something remain secret,
such as the password to your email account, or that it arrive
at its destination unmodified, such as the account number you transfer
money to from your bank&#8217;s website, plain HTTP is not good enough.</p>
<p><a class=p_ident id="p_s1KEZa2j+E" href="#p_s1KEZa2j+E"></a>The secure HTTP protocol, whose
URLs start with <em>https://</em>, wraps HTTP traffic in a way that makes
it harder to read and tamper with. First, the client verifies that the
server is who it claims to be by requiring that server to prove that it has a
cryptographic certificate issued by a certificate authority that
the browser recognizes. Next, all data going over the
connection is encrypted in a way that should prevent eavesdropping
and tampering.</p>
<p><a class=p_ident id="p_whG/pc2PK4" href="#p_whG/pc2PK4"></a>Thus, when it works right, HTTPS prevents both the
someone impersonating the website you were trying to talk to and the
someone snooping on your communication. It is not
perfect, and there have been various incidents where HTTPS failed because of
forged or stolen certificates and broken software. Still, plain
HTTP is trivial to mess with, whereas breaking HTTPS requires the kind
of effort that only states or sophisticated criminal organizations can
hope to make.</p>
<h2><a class=h_ident id="h_ErccPg/l98" href="#h_ErccPg/l98"></a>Summary</h2>
<p><a class=p_ident id="p_9mkfl3ctRV" href="#p_9mkfl3ctRV"></a>In this chapter, we saw that HTTP is a protocol for accessing
resources over the Internet. A <em>client</em> sends a request, which
contains a method (usually <code>GET</code>) and a path that identifies a
resource. The <em>server</em> then decides what to do with the request and
responds with a status code and a response body. Both requests and
responses may contain headers that provide additional information.</p>
<p><a class=p_ident id="p_QYlJoeSssL" href="#p_QYlJoeSssL"></a>Browsers make <code>GET</code> requests to fetch the resources needed to display
a web page. A web page may also contain forms, which allow information
entered by the user to be sent along in the request made when the form
is submitted. You will learn more about that in the <a href="18_forms.html#forms">next
chapter</a>.</p>
<p><a class=p_ident id="p_taYkCAtnud" href="#p_taYkCAtnud"></a>The interface through which browser JavaScript can make HTTP requests
is called <code>XMLHttpRequest</code>. You can usually ignore the “XML” part of
that name (but you still have to type it). There are two ways in which
it can be used—synchronous, which blocks everything until the request
finishes, and asynchronous, which requires an event handler to notice
that the response came in. In almost all cases, asynchronous is
preferable. Making a request looks like this:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_8UQ332N0tS" href="#c_8UQ332N0tS"></a><span class="cm-keyword">var</span> <span class="cm-variable">req</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">XMLHttpRequest</span>();
<span class="cm-variable">req</span>.<span class="cm-property">open</span>(<span class="cm-string">"GET"</span>, <span class="cm-string">"example/data.txt"</span>, <span class="cm-atom">true</span>);
<span class="cm-variable">req</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">req</span>.<span class="cm-property">status</span>);
});
<span class="cm-variable">req</span>.<span class="cm-property">send</span>(<span class="cm-atom">null</span>);</pre>
<p><a class=p_ident id="p_+TkoeLUgPt" href="#p_+TkoeLUgPt"></a>Asynchronous programming is tricky. <em>Promises</em> are an interface that
makes it slightly easier by helping route error conditions and
exceptions to the right handler and by abstracting away some of the more
repetitive and error-prone elements in this style of programming.</p>
<h2><a class=h_ident id="h_TcUD2vzyMe" href="#h_TcUD2vzyMe"></a>Exercises</h2>
<h3 id="exercise_accept"><a class=h_ident id="h_uaWwL8WGXf" href="#h_uaWwL8WGXf"></a>Content negotiation</h3>
<p><a class=p_ident id="p_4RSIQjkFSG" href="#p_4RSIQjkFSG"></a>One of the things that HTTP can do, but that
we have not discussed in this chapter, is called <em>content
negotiation</em>. The <code>Accept</code> header for a request can be used to tell
the server what type of document the client would like to get. Many
servers ignore this header, but when a server knows of various ways to
encode a resource, it can look at this header and send the one that
the client prefers.</p>
<p><a class=p_ident id="p_o+GIbRSLtv" href="#p_o+GIbRSLtv"></a>The URL
<a href="http://eloquentjavascript.net/author"><em>eloquentjavascript.net/author</em></a>
is configured to respond with either plaintext, HTML, or JSON,
depending on what the client asks for. These formats are identified by
the standardized <em>media types</em> <code>text/plain</code>, <code>text/html</code>, and
<code>application/json</code>.</p>
<p><a class=p_ident id="p_uUUGBBkyGq" href="#p_uUUGBBkyGq"></a>Send requests to
fetch all three formats of this resource. Use the <code>setRequestHeader</code>
method of your <code>XMLHttpRequest</code> object to set the header named <code>Accept</code>
to one of the media types given earlier. Make sure you set the header
<em>after</em> calling <code>open</code> but before calling <code>send</code>.</p>
<p><a class=p_ident id="p_ydN7YyErvr" href="#p_ydN7YyErvr"></a>Finally, try asking for the media type <code>application/rainbows+unicorns</code>
and see what happens.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_CfkOp8tkUe" href="#c_CfkOp8tkUe"></a><span class="cm-comment">// Your code here.</span></pre>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_TNktXshv5h" href="#p_TNktXshv5h"></a>See the
various examples of using an <code>XMLHttpRequest</code> in this chapter for an
example of the method calls involved in making a request. You can use
a synchronous request (by setting the third parameter to <code>open</code> to
<code>false</code>) if you want.</p>
<p><a class=p_ident id="p_rvMQauDbd6" href="#p_rvMQauDbd6"></a>Asking for a bogus
media type will return a response with code 406, “Not acceptable”,
which is the code a server should return when it can&#8217;t fulfill the
<code>Accept</code> header.</p>
</div></div>
<h3><a class=h_ident id="h_MlI+KUOVBK" href="#h_MlI+KUOVBK"></a>Waiting for multiple promises</h3>
<p><a class=p_ident id="p_bjI0ituzCO" href="#p_bjI0ituzCO"></a>The <code>Promise</code> constructor
has an <code>all</code> method that, given an array of promises, returns a
promise that waits for all of the promises in the array to finish. It then succeeds,
yielding an array of result values. If any of the promises in
the array fail, the promise returned by <code>all</code> fails too (with the
failure value from the failing promise).</p>
<p><a class=p_ident id="p_aWPI8r+IIn" href="#p_aWPI8r+IIn"></a>Try to implement something like this yourself as a regular function
called <code>all</code>.</p>
<p><a class=p_ident id="p_n5BsvIT7F5" href="#p_n5BsvIT7F5"></a>Note that after a promise is resolved (has succeeded or failed), it
can&#8217;t succeed or fail again, and further calls to the functions that
resolve it are ignored. This can simplify the way you handle failure
of your promise.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_GcukQjvcmk" href="#c_GcukQjvcmk"></a><span class="cm-keyword">function</span> <span class="cm-variable">all</span>(<span class="cm-def">promises</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>(<span class="cm-keyword">function</span>(<span class="cm-def">success</span>, <span class="cm-def">fail</span>) {
    <span class="cm-comment">// Your code here.</span>
  });
}

<span class="cm-comment">// Test code.</span>
<span class="cm-variable">all</span>([]).<span class="cm-property">then</span>(<span class="cm-keyword">function</span>(<span class="cm-def">array</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"This should be []:"</span>, <span class="cm-variable-2">array</span>);
});
<span class="cm-keyword">function</span> <span class="cm-variable">soon</span>(<span class="cm-def">val</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>(<span class="cm-keyword">function</span>(<span class="cm-def">success</span>) {
    <span class="cm-variable">setTimeout</span>(<span class="cm-keyword">function</span>() { <span class="cm-variable-2">success</span>(<span class="cm-variable-2">val</span>); },
               <span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-number">500</span>);
  });
}
<span class="cm-variable">all</span>([<span class="cm-variable">soon</span>(<span class="cm-number">1</span>), <span class="cm-variable">soon</span>(<span class="cm-number">2</span>), <span class="cm-variable">soon</span>(<span class="cm-number">3</span>)]).<span class="cm-property">then</span>(<span class="cm-keyword">function</span>(<span class="cm-def">array</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"This should be [1, 2, 3]:"</span>, <span class="cm-variable-2">array</span>);
});
<span class="cm-keyword">function</span> <span class="cm-variable">fail</span>() {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>(<span class="cm-keyword">function</span>(<span class="cm-def">success</span>, <span class="cm-def">fail</span>) {
    <span class="cm-variable-2">fail</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">"boom"</span>));
  });
}
<span class="cm-variable">all</span>([<span class="cm-variable">soon</span>(<span class="cm-number">1</span>), <span class="cm-variable">fail</span>(), <span class="cm-variable">soon</span>(<span class="cm-number">3</span>)]).<span class="cm-property">then</span>(<span class="cm-keyword">function</span>(<span class="cm-def">array</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"We should not get here"</span>);
}, <span class="cm-keyword">function</span>(<span class="cm-def">error</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">error</span>.<span class="cm-property">message</span> <span class="cm-operator">!=</span> <span class="cm-string">"boom"</span>)
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Unexpected failure:"</span>, <span class="cm-variable-2">error</span>);
});</pre>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_zV4HNd52Ay" href="#p_zV4HNd52Ay"></a>The
function passed to the <code>Promise</code> constructor will have to call <code>then</code>
on each of the promises in the given array. When one of them succeeds,
two things need to happen. The resulting value needs to be stored in
the correct position of a result array, and we must check whether this
was the last pending promise and finish our own promise if it
was.</p>
<p><a class=p_ident id="p_gVL8VQtmdx" href="#p_gVL8VQtmdx"></a>The latter can be done with a counter, which is
initialized to the length of the input array and from which we subtract
1 every time a promise succeeds. When it reaches 0, we are
done. Make sure you take the situation where the input array is empty
(and thus no promise will ever resolve) into account.</p>
<p><a class=p_ident id="p_xLxIRNCHYI" href="#p_xLxIRNCHYI"></a>Handling failure requires some thought but turns out to be extremely
simple. Just pass the failure function of the wrapping promise to each
of the promises in the array so that a failure in one of them
triggers the failure of the whole wrapper.</p>
</div></div>
<nav>
  <a href="16_canvas.html" title="capítulo previo">◀</a>
  <a href="index.html" title="cover">◆</a>
  <a href="18_forms.html" title="capítulo siguiente">▶</a>
</nav>
</article>
